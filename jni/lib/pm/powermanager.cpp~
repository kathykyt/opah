#include "ctlroot.h"
#include "flagdefine.h"
#include "powermanager.h"
#include "log.h"
#include "msgmanage.h"
#include <linux/input.h>


PowerManager powerManager;
static int is_cpu_sleep = 0;



#if __cplusplus
extern "C" {
#endif

static int pm_wake_lock_flag = 0;

/*
==========================================================================
   This function can set the bit flag asking system not to sleep
   on_off = 1 need to lock, don't sleep
   on_off = 0, can go sleep
==========================================================================
*/
void pm_wake_lock(int flags, int on_off) {

    //update the pm_wake_lock_flag
    pm_wake_lock_flag &= ~(1 << flags);
    pm_wake_lock_flag |= ((on_off & 0x1) << flags);


}

#if __cplusplus
};
#endif


void cpu_sleep(void)
{
	INFO_X("cpu_sleep\n");
/*
	char *buf = "mem";

	if((powerManager.pm_state_fd=open("/sys/power/state",O_WRONLY))<0)
	{
		ERROR_X("error! can not open /sys/power/state\n");
		return;
	}

	int ret ;
	ret = write(powerManager.pm_state_fd, buf, strlen(buf));
	INFO_X("cpu_sleep ret = %d\n", ret);
	
	close(powerManager.pm_state_fd);
*/
	system("echo mem > /sys/power/state");
}

void cpu_wakeup(void)
{
	INFO_X("cpu_wakeup\n");
/*
	char *buf = "on";

	if((powerManager.pm_state_fd=open("/sys/power/state",O_WRONLY))<0)
	{
		ERROR_X("error! can not open /sys/power/state\n");
		return;
	}

	write(powerManager.pm_state_fd, buf, strlen(buf)+1);

	close(powerManager.pm_state_fd);
*/
	system("echo on > /sys/power/state");
}


void Power_Loop(void)
{
	struct input_event data;

	for(;;)
	{
		if((powerManager.pm_input_fd=open("/dev/input/event1",O_RDONLY))<0)
		{
			ERROR_X("error! can not open /dev/input/event1\n");
			return;
		}

		read(powerManager.pm_input_fd, &data, sizeof(data));
		
		switch(data.type)
		{
			case EV_KEY:
				//INFO_X("data.code = %d\n", data.code);
				//INFO_X("data.value = %d\n", data.value);
				if(data.code==KEY_POWER){
					if(data.value){
						if(is_cpu_sleep){
							is_cpu_sleep = 0;
							//cpu_wakeup();
						}else{
							is_cpu_sleep = 1;
							//cpu_sleep();
						}
					}
				}
				break;
			default:
				break;
		}


		close(powerManager.pm_input_fd);

		memset(&data, 0, sizeof(data));
		
		//usleep(1 * 1000);
	}
}

int PowerManagerInit(CtlRoot* proot)
{
	INFO_X("PowerManagerInit\n");

	powerManager.root = proot;

	if(pthread_create(&(powerManager.g_thrdTemp),NULL,(void*(*)(void*))(Power_Loop),NULL))
	{
		ERROR_X("error! powerManager_Thread_Init fail\n");
		return -1;
	}

	system("echo 1 > /sys/class/axppower/axp_power_key");
	
	INFO_X("PowerManagerInit\n");
	return 0;
}

